 (********************************************************************************************************************************************************************)
 (*******Here I used for mul for ** and modd for %%  *****************)
 signature BIGNAT =
sig
type bignat=int list
val zero:bignat
exception underflow
exception overflow
exception division_by_zero
val fact : bignat -> bignat
val normalize : bignat -> bignat
val fromString : string -> bignat
val toString : bignat -> string
val ++ : bignat * bignat -> bignat
val succ : bignat -> bignat
val min : bignat * bignat -> bignat
val max : bignat * bignat -> bignat
val mul : bignat * bignat -> bignat
val << : bignat * bignat -> bool
val <<== : bignat * bignat -> bool
val >> : bignat * bignat -> bool
val >>== : bignat * bignat -> bool
val == : bignat * bignat -> bool
val len : bignat -> int
val compare : bignat * bignat -> order
val lenLt : bignat * bignat -> bool
val lenCompare : bignat * bignat -> order
val lenLeq : bignat * bignat -> bool
val lenGt : bignat * bignat -> bool
val lenGeq : bignat * bignat -> bool
val lenEq : bignat * bignat -> bool
val -- : bignat * bignat -> bignat
val take:bignat*int->bignat
val drop:bignat*int->bignat
val pred : bignat -> bignat
val quo:bignat*bignat->bignat
val rem:bignat*bignat->bignat
val modd:bignat*bignat->bignat*bignat
end

(***********************************************************************************************************************************************************************************)

structure BigNat :> BIGNAT =
  struct
  type bignat= int list
  exception overflow
    exception underflow
      exception division_by_zero
(***********************************************************************************************************************************************************************************)  

val zero=[0]  

(***********************************************************************************************************************************************************************************)

fun toBig(li:char list)=
        case li of
        []=>[]
       |x::xs=>(Char.ord(x)-48)::toBig(xs);

(***********************************************************************************************************************************************************************************)

fun fromString("") = raise underflow
       | fromString (a:string):bignat =
               let val lis=explode a
               in toBig(List.rev(lis))
               end

(***********************************************************************************************************************************************************************************)

fun normalize([])=[]
   | normalize(ll)=
                 let 
                    fun rnormalize([])=[]
                           |rnormalize(x::xs')=
                       if(x=0) then rnormalize(xs')
                         else x::xs'
                   in  List.rev(rnormalize(List.rev(ll)))
                end               	

(***********************************************************************************************************************************************************************************)

fun toString([])=""
       | toString(l)=
          let
              val aa=normalize(l)
              fun toS([])=""
                 |toS(x::xs) =toS(xs)^Int.toString(x) ; 
           in toS(aa)
       end               

(***********************************************************************************************************************************************************************************)

fun fulladder(a, b, c) = 
   let
    val carry = (a+b+c) div 10;
    val sum =(a+b+c) mod 10;
   in (sum, carry) end; 

(***********************************************************************************************************************************************************************************)

fun replicate(x, n) = 
	if n < 1
	then []
	else x@replicate(x, n-1);

(***********************************************************************************************************************************************************************************)

fun ++(l:int list,ll:int list)=
     let
      fun adder(x::xs, y::ys, cin) = 
          let val (s, cout) = fulladder(x, y, cin);
          in s :: adder(xs, ys, cout) end
      | adder([], [], c) = [c]
      |adder(x,y,c)=[]   
    in  adder(l@replicate([0],List.length(ll)-List.length(l)),ll@replicate([0],List.length(l)-List.length(ll)),0)
    end

(***********************************************************************************************************************************************************************************)

  fun len (l) = List.length (normalize(l));
 fun ==([],[])=true
       | ==([],_)=false
       | ==(_,[])=false
       | == (l:bignat,ll:bignat) =
       let 
           val ldash=normalize(l)
           val lldash=normalize(ll)
        fun compare([],[])=true
               | compare(l:bignat,ll:bignat)=
               if(hd(l)=hd(ll))
                   then ==(tl(l),tl(ll))
                 else
                   false
             in
                if(len(l)>len(ll))
                then false
               else if(len(l)<len(ll))
                 then false
               else
                  compare(ldash,lldash)
           end        

(***********************************************************************************************************************************************************************************)

fun >>([],_)=false
       | >>(l:bignat,ll:bignat )=
               if(==(l,ll))
                 then false
                else if(len(l)>len(ll))
                then true
                else if(len(l)<len(ll))
                then false             
              else
               let
                 
               fun headd(r,re)=
                      if(hd(r)>hd(re))
                         then true
                     else if (hd(r)<hd(re))
                         then false
                      else 
                          headd(tl(r),tl(re))
                     in headd(List.rev(normalize(l)),List.rev(normalize(ll)))
                     end;

(***********************************************************************************************************************************************************************************)

fun >>==(l:bignat,ll:bignat)=
               if(==(l,ll))
                 then true
                else if(>>(l,ll))
                   then true
                 else
                   false;

(***********************************************************************************************************************************************************************************)

  fun <<==([],[])=true
        | <<==(l:bignat,ll:bignat )=
            let 
               val aa=normalize(l)
               val bb=normalize(ll)
             in  
               if(==(aa,bb))
                 then true
              else if(>>(aa,bb))
                then false
              else
                 true
              end   

(***********************************************************************************************************************************************************************************)

 fun <<(l:bignat,ll:bignat)=
           if(>>==(l,ll))
            then false
             
           else
            true;      

(***********************************************************************************************************************************************************************************)

fun min(l:bignat,ll:bignat)=
            if(>>(l,ll))
              then ll
             else
               l;

(***********************************************************************************************************************************************************************************)

fun max(l:bignat,ll:bignat)=
         if(<<(l,ll))
          then ll
         else
         l;
   
                           
(***********************************************************************************************************************************************************************************)

fun pred(l:bignat)=
        case  l of 
        []=>[]
       |(x::xs) =>  if(x>0)
                            then  (x-1)::xs
                            else
                               [9]@pred(xs);

(***********************************************************************************************************************************************************************************)

 fun succ(l:bignat)=
        case l of 
        []=>[]
       |(x::xs) => if(x<9)
                             then (x+1)::xs
                          else
                             [0]@succ(xs) ;


(***********************************************************************************************************************************************************************************)

fun    compare( [] , [] )  = EQUAL 
         | compare ( l: bignat , ll: bignat ) =
          if( << ( l,  ll ) )
             then LESS
          else if(  == ( l , ll) )
            then EQUAL
          else
             GREATER     

(***********************************************************************************************************************************************************************************)

fun    lenCompare( [] , [] )  =  EQUAL
         | lenCompare ( l: bignat , ll: bignat ) =
          if( len(l) < len(ll) )
             then LESS
          else if( len (l) =len (ll) )
            then EQUAL
          else
             GREATER     

(***********************************************************************************************************************************************************************************)

 fun lenLt(l:bignat,ll:bignat)=
         if(len(l)<len(ll))
           then   true
           else
           false;

(***********************************************************************************************************************************************************************************)

fun lenLeq(l:bignat,ll:bignat)=
         if(len(l)<len(ll))
           then   true
           else if(len(l)=len(ll))
             then true
           else
           false;

(***********************************************************************************************************************************************************************************)

fun lenEq(l:bignat,ll:bignat)=
         if(len(l)=len(ll))
           then   true
        else
           false;

(***********************************************************************************************************************************************************************************)

 fun lenGeq(l:bignat,ll:bignat)=
         if(len(l)=len(ll))
           then   true
        else if(len(l)>len(ll))
            then true
         else
           false;

(***********************************************************************************************************************************************************************************)

  fun lenGt(l:bignat,ll:bignat)=
         if(len(l)>len(ll))
           then   true
       else
           false;

(***********************************************************************************************************************************************************************************)

fun f [] = []
  | f (x::xs) =  ~x::f (xs);

(***********************************************************************************************************************************************************************************)

fun --(l,ll)
   =  if(<<(l,ll))
          then ++(ll,f(l))
       else
              ++(l,f(ll));

(***********************************************************************************************************************************************************************************)

fun  mul([],_)=[]
        |mul(l:bignat,ll:bignat)=
         let   
            fun  mull(x:int,hg:bignat) =
                          if(x=0)
                            then  []
                           else
                              ++(hg,mull((x-1) ,hg))
        in      
               ++(mull(hd(l),ll),mul(tl(l),[0]@ll))
       
       end 

(***********************************************************************************************************************************************************************************)

fun drop(xs, n) =
	if n < 0 then []
	else if n = 0 then xs
	else 
		case xs of 
			[] => []
		  | (_::xs') => drop(xs', n-1)

(***********************************************************************************************************************************************************************************)

 fun take(xs, n) =
	if n < 0 
	then []
	else 
		case xs of 
			[] => []
		  | (x::xs') => if n > 0 then x::take(xs',n-1) else [] 

(***********************************************************************************************************************************************************************************)

fun  quo(l:bignat,[0]) = raise division_by_zero
       | quo(l:bignat,ll:bignat)=		  
if(normalize(ll)=[1])
   then l
else          
 let
   fun divide([],_,code,1)=[]
    |divide(l:bignat,[],code,1)=[0]
    |divide(l:bignat,ll:bignat,code,_)=
     let 
         fun calculator(div1,div2,ll)=                        
         if(<<==(mul(ll,[9]) ,div1))
                then  if(div2=[])
                            then [9]
                           else
                              divide(div2@normalize(--(div1,mul(ll,[9]))),ll,len(normalize(--(div1,mul(ll,[9]))))+1,2)@[9]
             else if(<<==(mul(ll,[8]),div1))
                    then  if(div2=[])
                                  then [8]
                               else
                                 divide(div2@normalize(--(div1,mul(ll,[8]))),ll,len(normalize(--(div1,mul(ll,[8]))))+1,2)@[8]
             else  if(<<==(mul(ll,[7]),div1))
                    then  if(div2=[])
                                   then [7]
                                else
                                    divide(div2@normalize(--(div1,mul(ll,[7]))),ll,len(normalize(--(div1,mul(ll,[7]))))+1,2)@[7] 
             else if(<<==(mul(ll,[6]),div1))
                    then if(div2=[])
                                then [6]
                              else  
                                 divide(div2@normalize(--(div1,mul(ll,[6]))),ll,len(normalize(--(div1,mul(ll,[6]))))+1,2)@[6]
              else if(<<==(mul(ll,[5]),div1))
                    then  if(div2=[])
                                   then  [5]
                                   else
                                     divide(div2@normalize(--(div1,mul(ll,[5]))),ll,len(normalize(--(div1,mul(ll,[5]))))+1,2)@[5]
               else if(<<==(mul(ll,[4]),div1))
                    then  if(div2=[])
                                 then [4]
                              else
                                 divide(div2@normalize(--(div1,mul(ll,[4]))),ll,len(normalize(--(div1,mul(ll,[4]))))+1,2)@[4]
                else if(<<==(mul(ll,[3]),div1))
                      then  if(div2=[])
                                      then [3]
                                    else
                                       divide(div2@normalize(--(div1,mul(ll,[3]))),ll,len(normalize(--(div1,mul(ll,[3]))))+1,2)@[3]
                       
                   else if(<<==(mul(ll,[2]),div1))
                      then  if(div2=[])
                                 then [2]
                                   else
                                   divide(div2@normalize(--(div1,mul(ll,[2]))),ll,len(normalize(--(div1,mul(ll,[2]))))+1,2)@[2]
                 else if(<<==(mul(ll,[1]),div1))
                      then if(div2=[])
                                    then [1]
                                else 
                                    divide(div2@normalize(--(div1,mul(ll,[1]))),ll,len(normalize(--(div1,mul(ll,[1]))))+1,2)@[1]
                 else 
                     divide(div2@div1,ll,code+1,2)@[0]
        in     
             if(<<(l,ll))
                    then [0]  
             else
                calculator(drop(l,len(l)-code),take(l,len(l)-code),ll)
         end 
     in
         divide(normalize(l),normalize(ll),len(ll),1)
    end                

 (***********************************************************************************************************************************************************************************) 


 fun fact ( l:bignat )=
           if(==(l,[0]))
              then [1]
            else   
               mul (l,fact(pred(l)))


 (***********************************************************************************************************************************************************************************)
 
    fun rem(l:bignat,ll:bignat)=
           --(l,mul(quo(l,ll),ll))     
 
 (***********************************************************************************************************************************************************************************)
 
    fun modd(l:bignat,ll:bignat)=
           (quo(l,ll),rem(l,ll))   
    end;

(***********************************************************************************************************************************************************************************)    

    open BigNat 
    


(***********************************************************************************************************************************************************************************)    
(***********************************************************************************************************************************************************************************)
(***********************************************************************************************************************************************************************************)    


 (*******Here I used modd for %%  *****************)

    functor BigInt (Bn: BIGNAT) :
    sig 
        datatype bigint = pair  of (bignat * int) 
 val bigzero: bigint 
 val fromString : string -> bigint 
 val toString : bigint -> string
val compare : bigint * bigint ->order
val lenCompare : bigint * bigint ->order
val normalize : bigint -> bigint
val abs : bigint -> bigint
val succ : bigint -> bigint
val ++ : bigint * bigint -> bigint
val sameSign : bigint * bigint -> bool
val ~~ : bigint->bigint
val min : bigint * bigint -> bigint
val max : bigint * bigint -> bigint
val ** : bigint * bigint -> bigint
val -- : bigint*bigint->bigint
val sign : bigint -> string
val quo : bigint *bigint-> bigint
val rem : bigint *bigint-> bigint
val modd : bigint *bigint-> string * string
val len : bigint -> int
val pred : bigint -> bigint
val lenLt : bigint * bigint -> bool
val lenLeq : bigint * bigint -> bool
val lenGt : bigint * bigint -> bool
val lenGeq : bigint * bigint -> bool
val lenEq : bigint * bigint -> bool
val << : bigint * bigint -> bool
val <<== : bigint * bigint -> bool
val >> : bigint * bigint -> bool
val >>== : bigint * bigint -> bool
val == : bigint * bigint -> bool
        end
        =
        struct 
            datatype bigint = pair  of (bignat * int);
 
 (***********************************************************************************************************************************************************************************)
 
    val bigzero=pair([0],1)
 
 (***********************************************************************************************************************************************************************************)
 
    fun abs(pair(x,y))=
                  pair(x,0)
 
 (***********************************************************************************************************************************************************************************)
 
     fun ~~(pair(x,y)) = pair(x,1)                 
 
 (***********************************************************************************************************************************************************************************)
 
     fun **(pair(x1,y1),pair(x2,y2)) = 
                if (y1 = y2)
                then pair (mul(x1,x2),0)
              else
               pair (mul(x1,x2),1)             
  
(***********************************************************************************************************************************************************************************)
  
    fun sameSign( pair(x1,y1),pair(x2,y2))=
            if(y1=y2)
               then true
             else
               false           

(***********************************************************************************************************************************************************************************)

    fun ==(pair(x1,y1),pair(x2,y2))=
                   if(Bn.==(x1,x2))
                         then if(y1=y2)
                                      then true 
                                   else
                                       false 
                  else
                      false

(***********************************************************************************************************************************************************************************)

  fun <<(pair(x1,y1),pair(x2,y2))=
              if(y1<y2)
                  then false
               else if(y1>y2)
                     then true
                 else 
                    if(Bn.==(x1,x2))
                          then  false
                     else if (Bn.<<(x1,x2))
                              then if(y1=0)
                                     then true
                                     else
                                        false
                     else 
                       if(y1=0)
                          then false
                        else
                           true                            

(***********************************************************************************************************************************************************************************)

  fun <<== (l:bigint,ll:bigint ) =
            if(==(l,ll))
               then true
            else if(<<(l,ll))
               then true
             else
              false

(***********************************************************************************************************************************************************************************)

 fun >> (l:bigint,ll:bigint) =
       if(<<==(l,ll))
          then false
         else
          true

(***********************************************************************************************************************************************************************************)

 fun >>== (l:bigint,ll:bigint) =        
           if(<<(l,ll))
             then false
           else true  

(***********************************************************************************************************************************************************************************)

 fun min  (l:bigint ,ll :bigint)=
      if(<<==(l,ll))
         then l                                      
     else
        ll

(***********************************************************************************************************************************************************************************)

fun max (l:bigint , ll:bigint)=
      if(>>==(l,ll))
         then l
       else
         ll  
                                                                                                                        

(***********************************************************************************************************************************************************************************)

    fun  ++(pair(x1,y1),pair(x2,y2))=
              if(Bn.<<(x1,x2))
                then if(y2>y1)
                           then pair(Bn.--(x2,x1),1) 
                         else if(y1=y2)
                            then pair( Bn.++(x1,x2), y1)
                          else
                             pair(Bn.--(x2,x1),0) 
              else if(Bn.>>(x1,x2))
                   then if(y1>y2)
                               then pair(Bn.--(x1,x2),1) 
                             else if(y2>y1)
                                then pair(Bn.--(x1,x2),0) 
                              else
                                 pair(Bn.++(x1,x2),y1)                  
                else 
                  if (y1=y2)
                       then pair(Bn.++(x1,x1),y1)
                      else
                     pair([0],1)   

(***********************************************************************************************************************************************************************************)

      fun succ(pair(x,y))=
               ++(pair(x,y),pair([1],0))

(***********************************************************************************************************************************************************************************)

       fun pred(pair(x,y))=
               ++(pair(x,y),pair([1],1))                 

(***********************************************************************************************************************************************************************************)

     fun  --(pair(x1,y1),pair(x2,y2))=
           if(y2=0)
                  then  ++(pair(x1,y1),pair(x2,1))
             else
                      ++(pair(x1,y1),pair(x2,0))    

(***********************************************************************************************************************************************************************************)

   fun   fromString ("")= raise underflow
             |fromString (l:string)=
                let
                   val a=explode l
                   val b= tl(a)
                  val c=implode b
                in  
                   if(Char.ord(hd(a))=45)
                        then pair(Bn.fromString(c),1)
                       else
                          pair((Bn.fromString(l)),0)                    
               end  

                       
(***********************************************************************************************************************************************************************************)

      fun last(xs) =
	case xs of
		[] => raise List.Empty
  	 | (x::[]) => x
  	 | (_::xs') => last(xs')         

(***********************************************************************************************************************************************************************************)

     fun toString (pair(x,y))=
                   if(y=1)
                     then "-"^Bn.toString(x)
                   else
                       Bn.toString(x)  ;                                                                       

(***********************************************************************************************************************************************************************************)

  fun sign(pair(x,y))=
               if(y=0)
                  then "+"
                else
                  "-"   

(***********************************************************************************************************************************************************************************)

fun len(pair(x,y))=Bn.len(x)

(***********************************************************************************************************************************************************************************)

  fun normalize (pair([],l)) = pair([],l)
       | normalize(pair(x1,y1))=
             pair(Bn.normalize(x1),y1)

(***********************************************************************************************************************************************************************************)

  fun quo(pair(x1,y1),pair(x2,y2))=
             if(x2=[0])
                 then raise division_by_zero 
           else if(y1=y2)
              then if(y1=0)
                         then pair((Bn. quo(x1,x2)),y1)
                       else if(Bn.==(mul(Bn.quo(x1,x2),x2),x1))
                                then pair( Bn.quo(x1,x2),0)
                          else
                                   pair( Bn.++(Bn.quo(x1,x2),[1]),0)         
   
           else
                      if(y1<y2)
                        then  pair((Bn.quo(x1,x2)),1) 
                       else
                         if(Bn.==(mul(Bn.quo(x1,x2),x2),x1))
                                then pair( Bn.quo(x1,x2),1)
                          else
                                   pair( Bn.++(Bn.quo(x1,x2),[1]),1)  
   
   (***********************************************************************************************************************************************************************************)
   
      fun lenLt(pair(x1,y1),pair(x2,y))=
                    Bn.lenLt(x1,x2)
   
   (***********************************************************************************************************************************************************************************)
   
        fun lenLeq(pair(x1,y1),pair(x2,y))=
                    Bn.lenLeq(x1,x2)
   
   (***********************************************************************************************************************************************************************************)
   
          fun lenGt(pair(x1,y1),pair(x2,y))=
                    Bn.lenGt(x1,x2)
   
   (***********************************************************************************************************************************************************************************)
   
          fun lenGeq(pair(x1,y1),pair(x2,y))=
                    Bn.lenGeq(x1,x2)
   
   (***********************************************************************************************************************************************************************************)
   
       fun lenEq(pair(x1,y1),pair(x2,y))=
                    Bn.lenEq(x1,x2)                              
   
   
   (***********************************************************************************************************************************************************************************)

fun compare ( l:bigint ,ll:bigint )=
         if( <<(l,ll) )
               then LESS
           else if ( ==(l,ll) )
              then EQUAL
            else
               GREATER

(***********************************************************************************************************************************************************************************)
               
fun lenCompare ( l:bigint ,ll:bigint )=
         if( len(l) = len(ll) )
               then EQUAL
           else if ( len(l) <  len(ll) )
              then LESS
            else
               GREATER

  (***********************************************************************************************************************************************************************************)
   
    fun rem(pair(x1,y1),pair(x2,y2))=
         --(pair(x1,y1),normalize( **(quo(pair(x1,y1),pair(x2,y2)),pair(x2,y2))))      
   
  (***********************************************************************************************************************************************************************************)
   
     fun modd(l:bigint,ll:bigint)=
           (toString(quo(l,ll)),toString(rem(l,ll)))
         end   
         structure bigintstruc = BigInt (BigNat);
            open bigintstruc ;
            
            
